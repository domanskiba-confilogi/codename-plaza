const CONFILOGI_ICON_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1430 513.165"><g transform="translate(-48.264 -60.372)"><path d="M251.486,311.469q-48.185,0-73.414-26.8t-25.233-76.125q0-24.518,7.7-43.766a94.3,94.3,0,0,1,21.1-32.5,88.238,88.238,0,0,1,31.932-20.1,115.2,115.2,0,0,1,40.2-6.843,129.156,129.156,0,0,1,22.812,1.854,148.694,148.694,0,0,1,17.96,4.278,88.607,88.607,0,0,1,12.831,4.989q5.132,2.566,7.413,3.992l-12.832,35.923A107.747,107.747,0,0,0,280.71,148.1a101.382,101.382,0,0,0-27.514-3.425,60.756,60.756,0,0,0-20.1,3.425,45.459,45.459,0,0,0-17.393,10.974,54.643,54.643,0,0,0-12.118,19.531q-4.563,11.975-4.562,29.084a103.708,103.708,0,0,0,2.994,25.516,54.029,54.029,0,0,0,9.694,20.384,46.408,46.408,0,0,0,17.533,13.542q10.832,5,26.23,4.992a119.413,119.413,0,0,0,17.393-1.14,128.706,128.706,0,0,0,13.685-2.708,71.718,71.718,0,0,0,10.551-3.565q4.553-1.992,8.266-3.708l12.261,35.64q-9.409,5.706-26.517,10.264T251.486,311.469Z" transform="translate(252.491 108.554)" fill="white"/><path d="M247.5,128.164a237.6,237.6,0,0,1,27.94-5.846,229.942,229.942,0,0,1,35.923-2.708q19.1,0,31.792,4.989t20.1,14.115A55.1,55.1,0,0,1,373.8,160.383a115.351,115.351,0,0,1,3.138,27.94V273H334.457V193.455q0-20.528-5.415-29.081T308.8,155.821q-4.563,0-9.694.427c-3.425.283-6.467.621-9.123,1V273H247.5Z" transform="translate(481.041 143.03)" fill="white"/><path d="M356.08,99.737a82.238,82.238,0,0,1,19.814,2,95.4,95.4,0,0,1,13.258,4.278l-7.413,33.356a40.62,40.62,0,0,0-10.12-2.851,73.94,73.94,0,0,0-11.261-.854,34.608,34.608,0,0,0-12.975,2.137,20.036,20.036,0,0,0-8.266,5.846,22.557,22.557,0,0,0-4.278,8.84,45.649,45.649,0,0,0-1.28,11.117v7.413h52.46v35.357h-52.46V320.987H291.076V163.034q0-29.081,16.393-46.187T356.08,99.737Z" transform="translate(586.258 95.045)" fill="white"/><path d="M373.827,125.662q0,11.693-7.556,18.39a27.046,27.046,0,0,1-35.637,0q-7.56-6.7-7.556-18.39t7.556-18.39a27.046,27.046,0,0,1,35.637,0Q373.82,113.976,373.827,125.662Z" transform="translate(663.525 97.063)" fill="white"/><rect width="42.483" height="149.97" transform="translate(990.879 266.062)" fill="white"/><path d="M402.5,323.838q-18.53-.287-30.078-3.991t-18.247-10.4a34.451,34.451,0,0,1-9.123-16.253,87.568,87.568,0,0,1-2.424-21.528V106.58l42.483-6.843V263.108a55.921,55.921,0,0,0,.854,10.264,17.7,17.7,0,0,0,3.281,7.7,17.331,17.331,0,0,0,6.986,5.132,38.107,38.107,0,0,0,12.258,2.564Z" transform="translate(710.726 95.045)" fill="white"/><path d="M531.185,124.89c-4.842-1.041-9.936-1.953-15.249-2.721q-8-1.122-16.106-1.844-8.133-.712-15.833-.714-17.967,0-32.212,5.279a67.009,67.009,0,0,0-24.1,14.972,63.943,63.943,0,0,0-14.955,23.229,84.131,84.131,0,0,0-5.132,30.074q0,33.086,16.526,51.476,16.543,18.382,47.625,18.39a75.195,75.195,0,0,0,15.812-1.571,67.491,67.491,0,0,0,14.115-4.712v5.422q0,12.548-7.56,20.524t-25.8,7.983a123.614,123.614,0,0,1-24.943-2.284,124.924,124.924,0,0,1-20.944-6.262l-7.416,35.626a171.3,171.3,0,0,0,25.366,6.426,157.554,157.554,0,0,0,27.37,2.411q39.063,0,57.742-17.8,18.679-17.834,18.681-54.6V128.157C540.35,127.027,536.041,125.931,531.185,124.89Zm-29.511,98.224a46.652,46.652,0,0,1-9.7,3.981,42.078,42.078,0,0,1-12.251,1.714q-28.815,0-28.8-35.643,0-17.091,8.273-28.214t25.089-11.121c3.8,0,7.123.13,9.97.42s5.313.621,7.413,1.007Z" transform="translate(867.59 143.03)" fill="white"/><path d="M502.96,125.662q0,11.693-7.556,18.39a27.051,27.051,0,0,1-35.64,0q-7.56-6.7-7.556-18.39t7.556-18.39a27.051,27.051,0,0,1,35.64,0Q502.954,113.976,502.96,125.662Z" transform="translate(975.304 97.063)" fill="white"/><rect width="42.483" height="149.97" transform="translate(1431.789 266.062)" fill="white"/><path d="M343.188,165.916a72.362,72.362,0,0,0-15.119-24.8,67.844,67.844,0,0,0-23.225-15.98,76.147,76.147,0,0,0-29.8-5.7,75.328,75.328,0,0,0-29.511,5.7,69.338,69.338,0,0,0-23.372,15.98,72.942,72.942,0,0,0-15.4,24.8,89.6,89.6,0,0,0-5.569,32.212,92.7,92.7,0,0,0,5.426,32.359,73.729,73.729,0,0,0,15.1,25.089A66.68,66.68,0,0,0,244.965,271.7a76.737,76.737,0,0,0,30.078,5.7,77.556,77.556,0,0,0,30.365-5.7,66.806,66.806,0,0,0,23.246-16.123,70.4,70.4,0,0,0,14.829-25.089,97.637,97.637,0,0,0,5.132-32.359A91.965,91.965,0,0,0,343.188,165.916Zm-45.76,61.723Q289.6,239.2,275.043,239.2t-22.518-11.558q-7.995-11.534-7.98-31.208,0-19.693,7.98-30.952t22.518-11.247q14.54,0,22.385,11.247,7.836,11.283,7.836,30.952T297.428,227.639Z" transform="translate(369.244 142.629)" fill="white"/><path d="M503.908,165.916a72.364,72.364,0,0,0-15.119-24.8,67.858,67.858,0,0,0-23.229-15.98,80.049,80.049,0,0,0-59.309,0,69.352,69.352,0,0,0-23.375,15.98,72.935,72.935,0,0,0-15.392,24.8,89.532,89.532,0,0,0-5.569,32.212,92.692,92.692,0,0,0,5.422,32.359,73.5,73.5,0,0,0,15.119,25.089A66.582,66.582,0,0,0,405.684,271.7a82.982,82.982,0,0,0,60.443,0,66.805,66.805,0,0,0,23.246-16.123A70.444,70.444,0,0,0,504.2,230.486a97.639,97.639,0,0,0,5.129-32.359A91.579,91.579,0,0,0,503.908,165.916Zm-45.761,63.437q-7.836,11.56-22.389,11.541c-9.677,0-17.2-3.834-22.515-11.541q-7.995-11.554-7.98-31.225,0-19.667,7.98-30.932c5.313-7.5,12.838-11.268,22.515-11.268q14.546,0,22.389,11.268t7.833,30.932Q465.98,217.795,458.147,229.353Z" transform="translate(757.293 142.629)" fill="white"/><g transform="translate(48.264 60.372)"><path d="M303.461,461.53l-255.2-158.4.039-196.37,255.2,158.4Z" transform="translate(-48.264 51.636)" fill="#414293"/><path d="M48.264,415.139l255.2-158.4-.039-196.37L48.3,218.77Z" transform="translate(-48.264 -60.372)" fill="#f8b133"/><path d="M206.474,204.933,48.264,303.12l.055-196.355Z" transform="translate(-48.264 51.641)" fill="#1d1d1b"/></g></g></svg>
`;

const CONFILOGI_ONLY_LOGO_ICON_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 260 520" class="w-5"><g transform="translate(-48.264 -60.372)"><g transform="translate(48.264 60.372)"><path d="M303.461,461.53l-255.2-158.4.039-196.37,255.2,158.4Z" transform="translate(-48.264 51.636)" fill="#414293"/><path d="M48.264,415.139l255.2-158.4-.039-196.37L48.3,218.77Z" transform="translate(-48.264 -60.372)" fill="#f8b133"/><path d="M206.474,204.933,48.264,303.12l.055-196.355Z" transform="translate(-48.264 51.641)" fill="#1d1d1b"/></g></g></svg>
`;

function escapeHtml(str) {
	return String(str)
		.replace(/&/g, "&amp;")
		.replace(/</g, "&lt;")
		.replace(/>/g, "&gt;")
		.replace(/"/g, "&quot;")
		.replace(/'/g, "&#039;");
}

const LOGGED_IN_NAVBAR_ITEMS = [
	{ type: 'link', label: 'Reported problems', href: '/reported-problems.html' },
	{ type: 'link', label: 'Report problem', href: '/report-problem.html' },
	{ type: 'link', label: 'My account', href: '/my-account.html' },
	{
		type: 'dropdown',
		id: 'administration',
		label: 'Administration',
		menuWidth: 'w-64',
		items: [
			{ label: 'User management', href: '/administration/user-management.html' },
			{ label: 'Job title settings', href: '/administration/job-titles.html' },
			{ label: 'Company department settings', href: '/administration/company-departments.html' },
			{ label: 'Other settings', href: '/administration/other-settings.html' },
		]
	},
	{ type: 'link', label: 'Sign out', href: '/sign-out.html' }
];

const LOGGED_OUT_NAVBAR_ITEMS = [
	{ type: 'link', label: 'Forgot your password?', href: '/forgot-your-password.html' },
];

const LOGGED_IN_NAVBAR_ARGS = {
	ctaText: 'Contact',
	ctaHref: '/contact.html',
	items: LOGGED_IN_NAVBAR_ITEMS,
}

const LOGGED_OUT_NAVBAR_ARGS = {
	ctaText: 'Sign in',
	ctaHref: '/sign-in.html',
	items: LOGGED_OUT_NAVBAR_ITEMS,
}

function createApiConnector(config = {}) {
	const {
		baseUrl = '/api',            // np. "https://api.twojadomena.com"
		timeout = 15000,         // domyślny timeout 15s
		authStore = null,
		defaultHeaders = {},     // dodatkowe nagłówki jeżeli potrzebne
	} = config;

	const normalizeBase = (u) => (u || '').replace(/\/+$/, '');
	const toURL = (path) => `${normalizeBase(baseUrl)}${path}`;

	async function parseJsonSafe(resp) {
		const ct = resp.headers.get('content-type') || '';
		if (!ct.toLowerCase().includes('application/json')) return null;
		try {
			return await resp.json();
		} catch {
			return null;
		}
	}

	async function login({ email, password } = {}) {
		function result({ ok = null, validationError = null, unknownError = null }) {
			return { ok, validationError, unknownError };
		}

		email = email ?? '';
		password = password ?? '';

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const res = await fetch(toURL('/auth/login'), {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				body: JSON.stringify({ email, password }),
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (data && typeof data === 'object' && data.user && data.authorization_token) {
					return result({ ok: data });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			if (res.status === 400) {
				const data = await parseJsonSafe(res);
				// Backend zwraca zewnętrznie tagowane enumy, np.:
				// { "ValidationWithTranslation": { property_name, message, translation } }
				if (data && data.ValidationWithTranslation) {
					return result({ validationError: data.ValidationWithTranslation });
				}
				// Inne warianty 400 (Message/Validation bez tłumaczenia) traktujemy jako unknownError
				const err = new Error('Bad Request');
				err.details = data;
				err.status = 400;
				return result({ unknownError: err });
			}

			// 401 i inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });

		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	async function getLoggedInUser() {
		function result({ ok = null, unauthorizedError = null, unknownError = null }) {
			return { ok, unauthorizedError, unknownError };
		}

		if (authStore === null) {
			result({ unknownError: "Auth store has not been initialized" });
		}

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const authStore = createAuthStore();

			const res = await fetch(toURL('/auth/user'), {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${authStore.getAuthorizationToken()}`,
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (data && typeof data === 'object' && data.id && data.email && data.full_name) {
					return result({ ok: data });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			if (res.status === 401) {
				return result({
					unauthorizedError: new Error("Unauthorized"),
				});
			}

			// inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });
		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	async function getJobTitles() {
		function result({ ok = null, unknownError = null }) {
			return { ok, unknownError };
		}

		if (authStore === null) {
			result({ unknownError: "Auth store has not been initialized" });
		}

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const authStore = createAuthStore();

			const res = await fetch(toURL('/job-titles'), {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${authStore.getAuthorizationToken()}`,
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (Array.isArray(data)) {
					return result({ ok: data });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			// inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });
		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	async function getCompanyDepartments() {
		function result({ ok = null, unknownError = null }) {
			return { ok, unknownError };
		}

		if (authStore === null) {
			result({ unknownError: "Auth store has not been initialized" });
		}

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const authStore = createAuthStore();

			const res = await fetch(toURL('/company-departments'), {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${authStore.getAuthorizationToken()}`,
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (Array.isArray(data)) {
					return result({ ok: data });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			// inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });
		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	async function getLicenses() {
		function result({ ok = null, unknownError = null }) {
			return { ok, unknownError };
		}

		if (authStore === null) {
			result({ unknownError: "Auth store has not been initialized" });
		}

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const authStore = createAuthStore();

			const res = await fetch(toURL('/licenses'), {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${authStore.getAuthorizationToken()}`,
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (Array.isArray(data)) {
					return result({ ok: data });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			// inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });
		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	async function getSystemPermissions() {
		function result({ ok = null, unknownError = null }) {
			return { ok, unknownError };
		}

		if (authStore === null) {
			result({ unknownError: "Auth store has not been initialized" });
		}

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const authStore = createAuthStore();

			const res = await fetch(toURL('/system-permissions'), {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${authStore.getAuthorizationToken()}`,
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (Array.isArray(data)) {
					return result({ ok: data });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			// inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });
		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	async function getMailingGroups() {
		function result({ ok = null, unknownError = null }) {
			return { ok, unknownError };
		}

		if (authStore === null) {
			result({ unknownError: "Auth store has not been initialized" });
		}

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const authStore = createAuthStore();

			const res = await fetch(toURL('/mailing-groups'), {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${authStore.getAuthorizationToken()}`,
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (Array.isArray(data)) {
					return result({ ok: data });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			// inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });
		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	async function getLicenseToJobTitleMappings() {
		function result({ ok = null, unknownError = null }) {
			return { ok, unknownError };
		}

		if (authStore === null) {
			result({ unknownError: "Auth store has not been initialized" });
		}

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const authStore = createAuthStore();

			const res = await fetch(toURL('/job-titles/license-mappings'), {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${authStore.getAuthorizationToken()}`,
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (Array.isArray(data)) {
					return result({ ok: data.map(entry => ({ licenseId: entry.license_id, jobTitleId: entry.job_title_id })) });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			// inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });
		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	async function getSystemPermissionToJobTitleMappings() {
		function result({ ok = null, unknownError = null }) {
			return { ok, unknownError };
		}

		if (authStore === null) {
			result({ unknownError: "Auth store has not been initialized" });
		}

		const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
		const timer = controller ? setTimeout(() => controller.abort("request timed out"), timeout) : null;

		try {
			const authStore = createAuthStore();

			const res = await fetch(toURL('/job-titles/system-permission-mappings'), {
				method: 'GET',
				headers: {
					'Authorization': `Bearer ${authStore.getAuthorizationToken()}`,
					'Content-Type': 'application/json',
					...defaultHeaders,
				},
				signal: controller ? controller.signal : undefined,
			});

			if (timer) clearTimeout(timer);

			if (res.status === 200) {
				const data = await parseJsonSafe(res);
				if (Array.isArray(data)) {
					return result({ ok: data.map(entry => ({ systemPermissionId: entry.system_permission_id, jobTitleId: entry.job_title_id })) });
				}
				return result({
					unknownError: new Error('Unexpected 200 response shape'),
				});
			}

			// inne kody traktujemy jako unknownError
			const fallbackBody = await parseJsonSafe(res);
			const err = new Error(`HTTP ${res.status}`);
			err.status = res.status;
			err.details = fallbackBody;
			return result({ unknownError: err });
		} catch (e) {
			if (timer) clearTimeout(timer);
			// Abort lub błąd sieci
			const err = e instanceof Error ? e : new Error(String(e));
			return result({ unknownError: err });
		}
	}

	return { login, getLoggedInUser, getJobTitles, getCompanyDepartments, getLicenses, getSystemPermissions, getMailingGroups, getLicenseToJobTitleMappings, getSystemPermissionToJobTitleMappings };
}

// High-resolution time when available (browser/Node)
const now = () =>
	(typeof performance !== "undefined" && typeof performance.now === "function")
		? performance.now()
		: Date.now();

function createAccessibilityTimer(totalMs) {
	if (!Number.isFinite(totalMs) || totalMs < 0) {
		throw new TypeError("totalMs must be a non-negative number");
	}

	const startedAt = now();

	const api = {
		// Milliseconds left until totalMs has elapsed since creation
		remaining() {
			const elapsed = now() - startedAt;
			// ceil to ensure we never resolve earlier than totalMs
			return Math.max(0, Math.ceil(totalMs - elapsed));
		},

		// Milliseconds elapsed since creation
		elapsed() {
			return Math.max(0, now() - startedAt);
		},

		// Whether the timer has fully elapsed
		done() {
			return api.remaining() === 0;
		},

		// Wait until the remaining time elapses.
		// Optional AbortSignal support: wait(signal)
		wait(signal) {
			const ms = api.remaining();
			if (ms === 0) return Promise.resolve();

			return new Promise((resolve, reject) => {
				const id = setTimeout(resolve, ms);

				if (signal) {
					const onAbort = () => {
						clearTimeout(id);
						signal.removeEventListener("abort", onAbort);
						const err = (typeof DOMException !== "undefined")
							? new DOMException("Aborted", "AbortError")
							: Object.assign(new Error("Aborted"), { name: "AbortError" });
						reject(signal.reason ?? err);
					};

					if (signal.aborted) {
						onAbort();
					} else {
						signal.addEventListener("abort", onAbort, { once: true });
					}
				}
			});
		},
	};

	return api;
}

function createAuthStore(options = {}) {
	const STORAGE_KEY = options.storageKey || 'auth.token';

	// Fallback-safe localStorage access
	const storage = (() => {
		let available = false;
		try {
			if (typeof window !== 'undefined' && window.localStorage) {
				const t = '__auth_store_test__';
				window.localStorage.setItem(t, '1');
				window.localStorage.removeItem(t);
				available = true;
			}
		} catch (_) {
			available = false;
		}
		let memoryToken = null;

		return {
			set(token) {
				if (available) window.localStorage.setItem(STORAGE_KEY, token);
					else memoryToken = token;
			},
			get() {
				if (available) return window.localStorage.getItem(STORAGE_KEY);
				return memoryToken;
			},
			remove() {
				if (available) window.localStorage.removeItem(STORAGE_KEY);
					else memoryToken = null;
			},
		};
	})();

	// User is kept only in memory (not persisted)
	let inMemoryUser = null;

	return {
		// save token inside localStorage, without user
		setLoggedInUser(authentication_token, user) {
			if (typeof authentication_token === 'string' && authentication_token.length > 0) {
				storage.set(authentication_token);
			} else {
				// If no valid token provided, clear stored token
				storage.remove();
			}
			// Store user only in memory (session-scoped)
			inMemoryUser = user ?? null;
		},

		getLoggedInUser() {
			return inMemoryUser;
		},

		getAuthorizationToken() {
			return storage.get();
		},

		isUserLoggedIn() {
			const token = storage.get();
			return typeof token === 'string' && token.length > 0;
		},
	};
}

async function checkIsLoggedInMiddleware(authStore) {
	const apiConnector = createApiConnector();

	const result = await apiConnector.getLoggedInUser();

	if (result.unauthorizedError !== null) {
		window.location.href = '/sign-in.html';
	} else if (result.ok !== null) {
		authStore.setLoggedInUser(authStore.getAuthorizationToken(), result.ok);
	} else {
		const errorModal = mountModal("#error-modal-root", {
			title: "A critical error occured",
			contentHtml: `${result.unknownError}`,
			primaryAction: { 
				label: 'Refresh page', 
				onClick: (_, api) => {
					window.location.reload();
				} 
			},
		});

		errorModal.open();

		throw result.unknownError;
	}
}

function reportCriticalError(error) {
	const errorModal = mountModal("#error-modal-root", {
		title: "A critical error occured",
		contentHtml: `${error}`,
		primaryAction: { 
			label: 'Refresh page', 
			onClick: (_, api) => {
				window.location.reload();
			} 
		},
	});

	errorModal.open();
	
	throw error;
}
